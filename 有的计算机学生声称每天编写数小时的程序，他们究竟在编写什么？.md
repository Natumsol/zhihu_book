
#  [有的计算机学生声称每天编写数小时的程序，他们究竟在编写什么？](https://zhihu.com/questions/25283551)



[@you conquer](https://zhihu.com/people/b26ce26dc5769a08d171809d07d7af0e)

刷算法书<br>刷POJ<br>刷HDOJ<br>刷LeetCode<br>刷ProjectEuler<br><br>学Java<br>学LLVM<br>学Linux<br>学Python<br>学Haskell<br>学Clojure<br>学Erlang<br>学Linux内核<br>学服务器端编程<br><br>写专利<br>写论文<br>写需求文档<br>写项目申请书<br>写日后自己能看得懂的注释<br><br>读CPython源码<br>读Nginx源码<br>读glibc源码<br>读Redis源码<br>读大牛的Blog<br>读大牛的GitHub<br>读HackerNews<br>读Reddit<br>读Solidot<br><br>配Ubuntu Server<br>配OpenStack<br>配Git<br>配Vim<br>配Zsh<br>配KVM<br>配OpenVZ<br>配Docker<br>配Vagrant<br>配OpenVSwitch<br><br>写纯C，掉到pthread和mutex的坑里<br>为了提高性能，试图写lock-free的版本<br>写不出来<br>卒<br><br>写Python调用C模块，掉到ctypes的坑里<br>刚从ctypes的坑里爬出来，又掉进pickle的坑里<br>pickle的坑直接hack进去效果拔群，最后被GIL坑死<br>卒<br><br>写Java<br>老板丢给你一包class文件<br>告诉你已经没有源码了<br>让你修个历史遗留bug<br>只好反编译回去看<br>卒<br><br>写Java<br>部署的时候碰到了OpenJDK的bug<br>调试一整天<br>卒<br><br>写Haskell<br>自己智商不够<br>卒<br><br>写Clojure<br>启动/运行慢成狗<br>卒<br><br>为了实现某个功能开始自己造轮子<br>轮子造到一半觉得要写的完美是几乎不可能的事情<br>开始搜可以实现该功能的开源库<br>开始读充满了//TODO的开源库“文档”<br>文档读不懂or压根没文档<br>卒<br><br>虽然没有文档，起码有代码诶<br>SourceInsight/Eclipse/Ctags+Cscope出场，直接读代码<br>宏满天飞<br>模板满天飞<br>void ***满天飞<br>结构体指针数组满天飞<br>卒<br><br>开始安装开源库<br>缺某种奇怪的工具链<br>装！装！装！<br>依赖关系不满足<br>装！装！装！<br>最后遇上了dependency hell<br>卒<br><br>千辛万苦装上了库，开始动手写<br>怎么功能跟文档里说的不一样啊<br>怎么还有种种奇怪的限制<br>怎么性能还这么烂<br>怎么之前的单元测试也跪了<br>卒<br><br>好不容易写出来了<br>老板说：这尼玛是啥，这么丑<br>改！改！改！<br>老板又说：哎呀需求改了啊，三天能搞定不？<br>改！改！改！<br>当年写的时候糙快猛啊<br>当年写的时候没留好接口/做好模块化啊<br>当年写的时候没注意设计模式啊<br>忘了当年怎么写的了啊<br>卒<br><br>终于有点时间做自己的东西啦<br>做点什么好呢<br>做个简单的源代码静态分析+代码结构可视化工具吧<br>嘿嘿嘿<br>动态语言写起来爽读起来恶心写起源码分析工具来就是天坑啊<br>看书<br>看《Language Implementation Patterns》<br>看《Modern Compiler Implementation》<br>看《Types and Programming Languages》<br>看看看不完了<br>卒<br><br>靠<br>不写了<br>刷知乎去<br>哎呀轮子哥的答案看不懂啊<br>哎呀RednaxelaFX菊苣答案里的名词一个都没听说过啊<br>哎呀十几岁的高中生搞安全秒我几条街啊<br>卒<br><br>吾生也有涯，而知也无涯<br><br>你看，一天8个小时，怎么够啊